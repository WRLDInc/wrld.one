---
/**
 * Experimental WorldMap with:
 * - Grid-aligned data particles
 * - Collision detection with explosions
 * - Mouse hover explosions
 * - ASCII dataplane effect (cascading data characters)
 *
 * Use this in staging for testing new effects
 */
---

<div class="data-flow-bg-experimental" aria-hidden="true">
  <canvas id="dataFlowCanvasExp"></canvas>
  <div id="asciiDataplane" class="ascii-dataplane"></div>
</div>

<script>
  // Experimental grid-aligned data flow with explosions and ASCII effects
  const canvas = document.getElementById('dataFlowCanvasExp') as HTMLCanvasElement;
  const asciiContainer = document.getElementById('asciiDataplane') as HTMLDivElement;

  if (canvas && asciiContainer) {
    const ctx = canvas.getContext('2d');

    // Configuration
    const GRID_SIZE = 80;
    const PARTICLE_SPEED = 2.5;
    const DIRECTION_CHANGE_CHANCE = 0.03;
    const COLLISION_DISTANCE = 20;
    const MOUSE_EXPLOSION_RADIUS = 100;

    // ASCII characters for dataplane effect
    const DATA_CHARS = '01'.split('');
    const HEX_CHARS = '0123456789ABCDEF'.split('');
    const SYMBOLS = ['◊', '◇', '○', '●', '□', '■', '△', '▽', '⬡', '⬢'];

    // Mouse position
    let mouseX = -1000;
    let mouseY = -1000;
    let mouseActive = false;

    // Set canvas size
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    // Track mouse
    document.addEventListener('pointermove', (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
      mouseActive = true;
    });

    document.addEventListener('pointerleave', () => {
      mouseActive = false;
      mouseX = -1000;
      mouseY = -1000;
    });

    // Get theme colors
    function getColors() {
      const style = getComputedStyle(document.documentElement);
      const isDark = document.documentElement.getAttribute('data-theme') !== 'light' &&
                     !window.matchMedia('(prefers-color-scheme: light)').matches;
      return {
        primary: style.getPropertyValue('--accent-primary').trim() || '#3b82f6',
        secondary: style.getPropertyValue('--accent-secondary').trim() || '#f97316',
        purple: style.getPropertyValue('--accent-purple').trim() || '#8b5cf6',
        opacity: isDark ? 0.7 : 0.3
      };
    }

    function snapToGrid(value: number): number {
      return Math.round(value / GRID_SIZE) * GRID_SIZE;
    }

    type Direction = 0 | 1 | 2 | 3;

    function getVelocity(dir: Direction): { vx: number; vy: number } {
      switch (dir) {
        case 0: return { vx: 0, vy: -PARTICLE_SPEED };
        case 1: return { vx: PARTICLE_SPEED, vy: 0 };
        case 2: return { vx: 0, vy: PARTICLE_SPEED };
        case 3: return { vx: -PARTICLE_SPEED, vy: 0 };
      }
    }

    // Explosion particle
    class ExplosionParticle {
      x: number;
      y: number;
      vx: number;
      vy: number;
      life: number;
      maxLife: number;
      color: string;
      size: number;
      char: string;

      constructor(x: number, y: number, color: string) {
        this.x = x;
        this.y = y;
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 8 + 4;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.life = 0;
        this.maxLife = Math.random() * 30 + 20;
        this.color = color;
        this.size = Math.random() * 4 + 2;
        this.char = Math.random() > 0.7 ? HEX_CHARS[Math.floor(Math.random() * HEX_CHARS.length)] :
                    DATA_CHARS[Math.floor(Math.random() * DATA_CHARS.length)];
      }

      update(): boolean {
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= 0.95;
        this.vy *= 0.95;
        this.life++;
        return this.life < this.maxLife;
      }

      draw(ctx: CanvasRenderingContext2D, opacity: number) {
        const alpha = (1 - this.life / this.maxLife) * opacity;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = this.color;
        ctx.font = `bold ${this.size * 3}px monospace`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 10;
        ctx.fillText(this.char, this.x, this.y);
        ctx.shadowBlur = 0;
      }
    }

    // Grid Particle with collision detection
    class GridParticle {
      x: number;
      y: number;
      vx: number;
      vy: number;
      direction: Direction;
      size: number;
      color: string;
      trail: { x: number; y: number }[];
      maxTrail: number;
      life: number;
      maxLife: number;
      lastGridX: number;
      lastGridY: number;
      id: number;
      alive: boolean;

      constructor(id: number) {
        this.id = id;
        this.trail = [];
        this.alive = true;
        this.reset();
      }

      reset() {
        this.alive = true;
        const colors = getColors();
        const colorChoice = Math.random();
        this.color = colorChoice < 0.4 ? colors.primary :
                     colorChoice < 0.7 ? colors.secondary : colors.purple;

        const edge = Math.floor(Math.random() * 4) as Direction;

        switch (edge) {
          case 0:
            this.x = snapToGrid(Math.random() * canvas.width);
            this.y = 0;
            this.direction = 2;
            break;
          case 1:
            this.x = snapToGrid(canvas.width);
            this.y = snapToGrid(Math.random() * canvas.height);
            this.direction = 3;
            break;
          case 2:
            this.x = snapToGrid(Math.random() * canvas.width);
            this.y = snapToGrid(canvas.height);
            this.direction = 0;
            break;
          case 3:
            this.x = 0;
            this.y = snapToGrid(Math.random() * canvas.height);
            this.direction = 1;
            break;
        }

        const vel = getVelocity(this.direction);
        this.vx = vel.vx;
        this.vy = vel.vy;

        this.size = Math.random() * 2 + 2;
        this.trail = [];
        this.maxTrail = Math.floor(Math.random() * 15) + 20;
        this.life = 0;
        this.maxLife = Math.random() * 400 + 300;
        this.lastGridX = this.x;
        this.lastGridY = this.y;
      }

      isAtIntersection(): boolean {
        const onVerticalLine = Math.abs(this.x - snapToGrid(this.x)) < PARTICLE_SPEED;
        const onHorizontalLine = Math.abs(this.y - snapToGrid(this.y)) < PARTICLE_SPEED;
        return onVerticalLine && onHorizontalLine;
      }

      getPerpendicularDirections(): Direction[] {
        if (this.direction === 0 || this.direction === 2) {
          return [1, 3];
        }
        return [0, 2];
      }

      distanceTo(other: GridParticle): number {
        return Math.sqrt((this.x - other.x) ** 2 + (this.y - other.y) ** 2);
      }

      distanceToMouse(): number {
        return Math.sqrt((this.x - mouseX) ** 2 + (this.y - mouseY) ** 2);
      }

      update() {
        if (!this.alive) return;

        this.trail.push({ x: this.x, y: this.y });
        if (this.trail.length > this.maxTrail) {
          this.trail.shift();
        }

        if (this.isAtIntersection()) {
          const currentGridX = snapToGrid(this.x);
          const currentGridY = snapToGrid(this.y);

          if (currentGridX !== this.lastGridX || currentGridY !== this.lastGridY) {
            this.lastGridX = currentGridX;
            this.lastGridY = currentGridY;
            this.x = currentGridX;
            this.y = currentGridY;

            if (Math.random() < DIRECTION_CHANGE_CHANCE) {
              const perpDirs = this.getPerpendicularDirections();
              this.direction = perpDirs[Math.floor(Math.random() * perpDirs.length)];
              const vel = getVelocity(this.direction);
              this.vx = vel.vx;
              this.vy = vel.vy;
            }
          }
        }

        this.x += this.vx;
        this.y += this.vy;
        this.life++;

        const margin = 50;
        if (this.x < -margin || this.x > canvas.width + margin ||
            this.y < -margin || this.y > canvas.height + margin ||
            this.life > this.maxLife) {
          this.reset();
        }
      }

      draw(ctx: CanvasRenderingContext2D, globalOpacity: number) {
        if (!this.alive) return;

        if (this.trail.length > 1) {
          for (let i = 1; i < this.trail.length; i++) {
            const alpha = (i / this.trail.length) * 0.4 * globalOpacity;
            ctx.beginPath();
            ctx.moveTo(this.trail[i - 1].x, this.trail[i - 1].y);
            ctx.lineTo(this.trail[i].x, this.trail[i].y);
            ctx.strokeStyle = this.color;
            ctx.lineWidth = this.size * 0.5;
            ctx.lineCap = 'round';
            ctx.globalAlpha = alpha;
            ctx.stroke();
          }
        }

        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.globalAlpha = globalOpacity;
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 15;
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      explode(): ExplosionParticle[] {
        this.alive = false;
        const explosions: ExplosionParticle[] = [];
        const count = Math.floor(Math.random() * 10) + 8;
        for (let i = 0; i < count; i++) {
          explosions.push(new ExplosionParticle(this.x, this.y, this.color));
        }
        return explosions;
      }
    }

    // ASCII Dataplane - falling data characters
    class AsciiChar {
      x: number;
      y: number;
      speed: number;
      char: string;
      opacity: number;
      element: HTMLSpanElement;

      constructor() {
        this.element = document.createElement('span');
        this.element.className = 'ascii-char';
        asciiContainer.appendChild(this.element);
        this.reset();
      }

      reset() {
        this.x = Math.random() * window.innerWidth;
        this.y = -20;
        this.speed = Math.random() * 2 + 0.5;
        this.opacity = Math.random() * 0.15 + 0.05;
        this.char = Math.random() > 0.8 ?
          SYMBOLS[Math.floor(Math.random() * SYMBOLS.length)] :
          (Math.random() > 0.5 ? DATA_CHARS : HEX_CHARS)[Math.floor(Math.random() * (Math.random() > 0.5 ? 2 : 16))];
        this.updateElement();
      }

      updateElement() {
        this.element.textContent = this.char;
        this.element.style.left = `${this.x}px`;
        this.element.style.top = `${this.y}px`;
        this.element.style.opacity = `${this.opacity}`;
      }

      update() {
        this.y += this.speed;
        if (this.y > window.innerHeight + 20) {
          this.reset();
        }
        // Occasionally change character
        if (Math.random() < 0.02) {
          this.char = Math.random() > 0.8 ?
            SYMBOLS[Math.floor(Math.random() * SYMBOLS.length)] :
            (Math.random() > 0.5 ? '0' : '1');
        }
        this.updateElement();
      }

      remove() {
        this.element.remove();
      }
    }

    // Create particles
    const particles: GridParticle[] = [];
    const explosions: ExplosionParticle[] = [];
    const particleCount = Math.min(Math.floor(window.innerWidth / 60), 25);

    for (let i = 0; i < particleCount; i++) {
      const p = new GridParticle(i);
      p.life = Math.random() * p.maxLife;
      particles.push(p);
    }

    // Create ASCII chars
    const asciiChars: AsciiChar[] = [];
    const asciiCount = Math.min(Math.floor(window.innerWidth / 50), 40);
    for (let i = 0; i < asciiCount; i++) {
      const ac = new AsciiChar();
      ac.y = Math.random() * window.innerHeight; // Stagger initial positions
      asciiChars.push(ac);
    }

    let gridOffset = 0;

    // Animation loop
    function animate() {
      const colors = getColors();
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw grid
      ctx.globalAlpha = 0.03 * colors.opacity;
      ctx.strokeStyle = colors.primary;
      ctx.lineWidth = 1;

      gridOffset = (gridOffset + 0.1) % GRID_SIZE;

      for (let x = gridOffset; x < canvas.width + GRID_SIZE; x += GRID_SIZE) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }

      for (let y = gridOffset; y < canvas.height + GRID_SIZE; y += GRID_SIZE) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }

      // Draw intersection dots
      ctx.globalAlpha = 0.06 * colors.opacity;
      ctx.fillStyle = colors.primary;
      for (let x = gridOffset; x < canvas.width + GRID_SIZE; x += GRID_SIZE) {
        for (let y = gridOffset; y < canvas.height + GRID_SIZE; y += GRID_SIZE) {
          ctx.beginPath();
          ctx.arc(x, y, 1.5, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      // Check for collisions and mouse interactions
      for (let i = 0; i < particles.length; i++) {
        const p = particles[i];
        if (!p.alive) continue;

        // Mouse explosion
        if (mouseActive && p.distanceToMouse() < MOUSE_EXPLOSION_RADIUS) {
          explosions.push(...p.explode());
          setTimeout(() => p.reset(), 500);
          continue;
        }

        // Particle collision
        for (let j = i + 1; j < particles.length; j++) {
          const other = particles[j];
          if (!other.alive) continue;

          if (p.distanceTo(other) < COLLISION_DISTANCE) {
            // Both explode!
            explosions.push(...p.explode());
            explosions.push(...other.explode());
            setTimeout(() => p.reset(), 500);
            setTimeout(() => other.reset(), 500);
            break;
          }
        }
      }

      // Update and draw particles
      ctx.globalAlpha = 1;
      particles.forEach(p => {
        p.update();
        p.draw(ctx, colors.opacity);
      });

      // Update and draw explosions
      for (let i = explosions.length - 1; i >= 0; i--) {
        if (!explosions[i].update()) {
          explosions.splice(i, 1);
        } else {
          explosions[i].draw(ctx, colors.opacity);
        }
      }

      // Update ASCII chars
      asciiChars.forEach(ac => ac.update());

      requestAnimationFrame(animate);
    }

    animate();

    // Theme change observer
    const observer = new MutationObserver(() => {});
    observer.observe(document.documentElement, { attributes: true, attributeFilter: ['data-theme'] });

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      asciiChars.forEach(ac => ac.remove());
    });
  }
</script>

<style>
  .data-flow-bg-experimental {
    position: fixed;
    inset: 0;
    z-index: 0;
    pointer-events: none;
    overflow: hidden;
  }

  #dataFlowCanvasExp {
    width: 100%;
    height: 100%;
    position: absolute;
    inset: 0;
  }

  .ascii-dataplane {
    position: absolute;
    inset: 0;
    overflow: hidden;
    pointer-events: none;
  }

  :global(.ascii-char) {
    position: absolute;
    font-family: var(--font-mono, 'JetBrains Mono', monospace);
    font-size: 14px;
    color: var(--accent-primary, #3b82f6);
    user-select: none;
    pointer-events: none;
    text-shadow: 0 0 8px currentColor;
  }

  /* Light mode adjustments */
  :global([data-theme="light"]) .ascii-char {
    text-shadow: 0 0 4px currentColor;
  }

  @media (prefers-color-scheme: light) {
    :global(html:not([data-theme])) .ascii-char {
      text-shadow: 0 0 4px currentColor;
    }
  }

  /* Hide in reduced motion */
  @media (prefers-reduced-motion: reduce) {
    .data-flow-bg-experimental {
      display: none;
    }
  }
</style>
