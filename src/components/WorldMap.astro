---
---

<div class="data-flow-bg" aria-hidden="true">
  <canvas id="dataFlowCanvas"></canvas>
</div>

<script>
  // Grid-aligned data flow animation
  const canvas = document.getElementById('dataFlowCanvas') as HTMLCanvasElement;
  if (canvas) {
    const ctx = canvas.getContext('2d');

    // Grid configuration
    const GRID_SIZE = 80;
    const PARTICLE_SPEED = 2;
    const DIRECTION_CHANGE_CHANCE = 0.02; // Chance to turn at intersections

    // Set canvas size
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    // Get theme colors
    function getColors() {
      const style = getComputedStyle(document.documentElement);
      const isDark = document.documentElement.getAttribute('data-theme') !== 'light' &&
                     !window.matchMedia('(prefers-color-scheme: light)').matches;
      return {
        primary: style.getPropertyValue('--accent-primary').trim() || '#3b82f6',
        secondary: style.getPropertyValue('--accent-secondary').trim() || '#f97316',
        purple: style.getPropertyValue('--accent-purple').trim() || '#8b5cf6',
        opacity: isDark ? 0.6 : 0.25
      };
    }

    // Snap to nearest grid line
    function snapToGrid(value: number): number {
      return Math.round(value / GRID_SIZE) * GRID_SIZE;
    }

    // Direction enum: 0=up, 1=right, 2=down, 3=left
    type Direction = 0 | 1 | 2 | 3;

    // Get velocity from direction
    function getVelocity(dir: Direction): { vx: number; vy: number } {
      switch (dir) {
        case 0: return { vx: 0, vy: -PARTICLE_SPEED }; // Up
        case 1: return { vx: PARTICLE_SPEED, vy: 0 };  // Right
        case 2: return { vx: 0, vy: PARTICLE_SPEED };  // Down
        case 3: return { vx: -PARTICLE_SPEED, vy: 0 }; // Left
      }
    }

    // Grid Particle class - moves only on grid lines
    class GridParticle {
      x: number;
      y: number;
      vx: number;
      vy: number;
      direction: Direction;
      size: number;
      color: string;
      trail: { x: number; y: number }[];
      maxTrail: number;
      life: number;
      maxLife: number;
      lastGridX: number;
      lastGridY: number;

      constructor() {
        this.trail = [];
        this.reset();
      }

      reset() {
        const colors = getColors();
        const colorChoice = Math.random();
        this.color = colorChoice < 0.4 ? colors.primary :
                     colorChoice < 0.7 ? colors.secondary : colors.purple;

        // Spawn on a random edge, aligned to grid
        const edge = Math.floor(Math.random() * 4) as Direction;

        switch (edge) {
          case 0: // Top edge, moving down
            this.x = snapToGrid(Math.random() * canvas.width);
            this.y = 0;
            this.direction = 2; // Down
            break;
          case 1: // Right edge, moving left
            this.x = snapToGrid(canvas.width);
            this.y = snapToGrid(Math.random() * canvas.height);
            this.direction = 3; // Left
            break;
          case 2: // Bottom edge, moving up
            this.x = snapToGrid(Math.random() * canvas.width);
            this.y = snapToGrid(canvas.height);
            this.direction = 0; // Up
            break;
          case 3: // Left edge, moving right
            this.x = 0;
            this.y = snapToGrid(Math.random() * canvas.height);
            this.direction = 1; // Right
            break;
        }

        const vel = getVelocity(this.direction);
        this.vx = vel.vx;
        this.vy = vel.vy;

        this.size = Math.random() * 2 + 2;
        this.trail = [];
        this.maxTrail = Math.floor(Math.random() * 15) + 20;
        this.life = 0;
        this.maxLife = Math.random() * 400 + 300;
        this.lastGridX = this.x;
        this.lastGridY = this.y;
      }

      // Check if at a grid intersection
      isAtIntersection(): boolean {
        const onVerticalLine = Math.abs(this.x - snapToGrid(this.x)) < PARTICLE_SPEED;
        const onHorizontalLine = Math.abs(this.y - snapToGrid(this.y)) < PARTICLE_SPEED;
        return onVerticalLine && onHorizontalLine;
      }

      // Get perpendicular directions
      getPerpendicularDirections(): Direction[] {
        if (this.direction === 0 || this.direction === 2) {
          return [1, 3]; // Moving vertically, can turn horizontal
        }
        return [0, 2]; // Moving horizontally, can turn vertical
      }

      update() {
        // Add current position to trail
        this.trail.push({ x: this.x, y: this.y });
        if (this.trail.length > this.maxTrail) {
          this.trail.shift();
        }

        // Check for direction change at intersections
        if (this.isAtIntersection()) {
          const currentGridX = snapToGrid(this.x);
          const currentGridY = snapToGrid(this.y);

          // Only consider turning if we've moved to a new grid position
          if (currentGridX !== this.lastGridX || currentGridY !== this.lastGridY) {
            this.lastGridX = currentGridX;
            this.lastGridY = currentGridY;

            // Snap to exact grid position
            this.x = currentGridX;
            this.y = currentGridY;

            // Random chance to turn
            if (Math.random() < DIRECTION_CHANGE_CHANCE) {
              const perpDirs = this.getPerpendicularDirections();
              this.direction = perpDirs[Math.floor(Math.random() * perpDirs.length)];
              const vel = getVelocity(this.direction);
              this.vx = vel.vx;
              this.vy = vel.vy;
            }
          }
        }

        // Move
        this.x += this.vx;
        this.y += this.vy;
        this.life++;

        // Reset if out of bounds or life ended
        const margin = 50;
        if (this.x < -margin || this.x > canvas.width + margin ||
            this.y < -margin || this.y > canvas.height + margin ||
            this.life > this.maxLife) {
          this.reset();
        }
      }

      draw(ctx: CanvasRenderingContext2D, globalOpacity: number) {
        // Draw trail with gradient fade
        if (this.trail.length > 1) {
          for (let i = 1; i < this.trail.length; i++) {
            const alpha = (i / this.trail.length) * 0.4 * globalOpacity;
            ctx.beginPath();
            ctx.moveTo(this.trail[i - 1].x, this.trail[i - 1].y);
            ctx.lineTo(this.trail[i].x, this.trail[i].y);
            ctx.strokeStyle = this.color;
            ctx.lineWidth = this.size * 0.5;
            ctx.lineCap = 'round';
            ctx.globalAlpha = alpha;
            ctx.stroke();
          }
        }

        // Draw head with glow
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.globalAlpha = globalOpacity;
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 15;
        ctx.fill();
        ctx.shadowBlur = 0;
      }
    }

    // Create particles
    const particles: GridParticle[] = [];
    const particleCount = Math.min(Math.floor(window.innerWidth / 80), 20);
    for (let i = 0; i < particleCount; i++) {
      const p = new GridParticle();
      p.life = Math.random() * p.maxLife; // Stagger initial positions
      particles.push(p);
    }

    // Grid animation offset
    let gridOffset = 0;

    // Animation loop
    function animate() {
      const colors = getColors();
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw subtle static grid
      ctx.globalAlpha = 0.04 * colors.opacity;
      ctx.strokeStyle = colors.primary;
      ctx.lineWidth = 1;

      // Calculate grid offset for subtle movement
      gridOffset = (gridOffset + 0.1) % GRID_SIZE;

      // Vertical lines
      for (let x = gridOffset; x < canvas.width + GRID_SIZE; x += GRID_SIZE) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }

      // Horizontal lines
      for (let y = gridOffset; y < canvas.height + GRID_SIZE; y += GRID_SIZE) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }

      // Draw grid intersection dots
      ctx.globalAlpha = 0.08 * colors.opacity;
      ctx.fillStyle = colors.primary;
      for (let x = gridOffset; x < canvas.width + GRID_SIZE; x += GRID_SIZE) {
        for (let y = gridOffset; y < canvas.height + GRID_SIZE; y += GRID_SIZE) {
          ctx.beginPath();
          ctx.arc(x, y, 1.5, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      // Update and draw particles
      ctx.globalAlpha = 1;
      particles.forEach(p => {
        p.update();
        p.draw(ctx, colors.opacity);
      });

      requestAnimationFrame(animate);
    }

    animate();

    // Listen for theme changes
    const observer = new MutationObserver(() => {
      // Colors will be re-fetched on next frame
    });
    observer.observe(document.documentElement, { attributes: true, attributeFilter: ['data-theme'] });
  }
</script>

<style>
  .data-flow-bg {
    position: fixed;
    inset: 0;
    z-index: 0;
    pointer-events: none;
    overflow: hidden;
  }

  #dataFlowCanvas {
    width: 100%;
    height: 100%;
  }

  /* Hide in reduced motion */
  @media (prefers-reduced-motion: reduce) {
    .data-flow-bg {
      display: none;
    }
  }
</style>
